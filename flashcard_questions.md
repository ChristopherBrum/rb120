# OOP Questions

- Part 1: The Object Model
  - Why was OOP created and what purpose does it serve?
    - OOP was written in order to deal with the growing complexity of programs and the web of dependency they inevitably created. These interdependencies make it difficult to update or maintain programs without causing bugs and errors throughout a program.
    - OOP significantly reduced the dependencies within a program by encapsulating data into clearly organized code using classes, objects, and modules. By encapsulating functionality programmers were able to expose only the data/functionality that they needed to and essentially hide the rest within their respected containers. This added an additional layer of protection and security.
    - Additionally OOP allowed programmers to think about their programs in a more metaphorical by separating
  - What is encapsulation?
  - What is polymorphism?
  - What does inheritance mean when referring to OOP?
  - What are modules?
  - What can be considered an Object in Ruby?
  - What defines an object in Ruby?
  - What is instantiation?
  - When naming classes and class files what is the proper format?
  - What are modules used for?
  - How do we add behaviors defined by a module to a custom class?
  - what does method lookup refer to?
- Part 2: Classes and Objects I
  - What is state and how to we track it?
  - What is behavior and how do we define it?
  - How do we create a new instance of a class?
  - What method is called when you create a new method, besides the `BasicObject#new` method, and why?
  - What is an instance variable and why do we need them?
  - Do objects of the same class have the same states and behaviors?
  - When dealing with getter and setter methods how does Ruby's syntactical sugar help us?
  - What naming convention should we keep in mind when dealing with getter and setter methods?
  - What do setter methods always return?
  - What built in accessors methods does Ruby provide and what do they take in as arguments?
  - Instead of directly calling an instance variable from within an instance method, what is a preferable way of referencing the state of an object and why?
  - What do we need to add to a setter method within an instance variable to update the state and why?
  - When should we use the self keyword within an instance method?
- Part 3: Classes and Objects II
  - What is a class method and how do you define one?
  - How do you call a class method vs. calling an instance method?
  - Why would we need a class method?
  - When does the initialize method get called?
  - Why would we use a constant when we have class variables?
  - In what circumstance would we not need to define instance variables within the initialize instance method?
  - When calling the `puts` method, what other method is also called, and is it called always?
  - What are the similarities and differences of the `puts` and the `p` methods?
  - In what other circumstance is the `to_s` method automatically called?
  - How can we use the `to_s` method within our own custom classes?
  - Even though it's not always necessary, why is prepending getter and setter methods with `self` important?
  - What are 2 clear things that we can `self` for?
  - What are the boundaries of `self` within a class when determining whether you're referencing the class or an instance of the class?
- Part 4: Inheritance
  - How does inheritance effect behavior and what are the associated objects referred to?
  - What do we use to signify that a class is inheriting form another?
  - How can a subclass override the behavior of a superclass and how does this work?
  - What does the `super` keyword do?
  - How can we be more specific about what `super` passes or doesn't pass as an argument?
  - What happens if you use `super` when the subclass method has arguments passed in and the superclass method doesn't, or vice-versa?
  - What's a good example of where using class inheritance makes sense?
  - Why do we need modules if we can inherit from other classes?
  - What is a design principle that OOP helps us achieve?
  - What is the difference between class inheritance and interface inheritance?
  - What are the 3 main things to think about when determining whether class inheritance or a mixin is more appropriate for a situation?
  - What are 3 ways that we use modules?
  - What is important to keep in mind regarding the order in which mixins are added to a class?
  - What is the advantage of namespacing?
  - What do we use to reference a class or class method that is namespaced within a module?
  - When using a module as a container how would call a method contained within it?
  - When would we want to use a private method?
  - How is the `self` keyword affected when using a private method?
  - How is a private method scoped?
  - How do protected methods differ from private methods?
  - Is `initialize` a public, private or protected method?
  - What are the 3 types of method access control?
  - What are the 4 core programming concepts of OOP?
  - What does a constructor method return?
  - How many classes can a class inherit from?
  - How many modules can be mixed into a class?
- OOP in Depth
  - What is the difference between polymorphism through inheritance and duck-typing?
  - What is single inheritance?
- Conceptual Questions
  - Why is it generally safer to invoke a setter method (if available) vs. referencing the instance variable directly when trying to set an instance variable within the class? Give an example.
  - Give an example of when it would make sense to manually write a custom getter method vs. using `attr_reader`.
  - What is the difference between states and behaviors?
  - What is the difference between instance methods and class methods?
  - How do class inheritance and mixing in modules affect instance variable scope? Give an example.
  - How does encapsulation relate to the public interface of a class?  
    - Encapsulation in OOP is about separating our codebase into containers (classes) in order to reduce the dependencies that procedural programming were rife with. Furthermore in Ruby we have method access controls which give us the ability to restrict the access of class behaviors (methods) to the public interface. The public interface only needs access to certain behavior of a class and does not need to know how these behaviors or any private behaviors function. This adds a further layer of protection between data and the public interface as well as lessens dependencies.  
  - What are collaborator objects, and what is the purpose of using them in OOP? Give an example of how we would work with one.
  - How and why would we implement a fake operator in a custom class? Give an example.
  - What are the use cases for `self` in Ruby, and how does `self` change based on the scope it is used in? Provide examples.
  - When does accidental method overriding occur, and why? Give an example.
  - How is Method Access Control implemented in Ruby? Provide examples of when we would use public, protected, and private access modifiers.
  - Describe the distinction between modules and classes.
  - What is polymorphism and how can we implement polymorphism in Ruby? Provide examples.
  - What is encapsulation, and why is it important in Ruby? Give an example.
